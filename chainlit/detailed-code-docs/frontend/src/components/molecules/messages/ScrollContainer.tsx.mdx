---
title: "ScrollContainer.tsx"
---

## High-level description
The `ScrollContainer` component is a reusable React component that provides a scrollable container for chat messages. It manages auto-scrolling behavior and allows manual scrolling with the ability to toggle auto-scroll on and off.

## Code Structure
The main `ScrollContainer` component uses React hooks (`useEffect`, `useRef`) to manage its behavior. It interacts with the `useChatMessages` and `useChatSession` hooks from the Chainlit React client to access chat-related data.

## Symbols

### ScrollContainer
#### Description
A functional component that wraps its children in a scrollable container, managing auto-scroll behavior based on new messages and user interaction.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| setAutoScroll | (autoScroll: boolean) =&gt; void | Optional function to update the auto-scroll state |
| autoScroll | boolean | Optional flag to determine if auto-scroll is enabled |
| children | React.ReactNode | The content to be rendered inside the scroll container |

#### Internal Logic
1. Uses `useRef` to create a reference to the scrollable container.
2. Uses `useEffect` to handle auto-scrolling when new messages arrive or when the chat session changes.
3. Implements a `handleScroll` function to detect when the user has scrolled to the bottom and update the auto-scroll state accordingly.

#### Side Effects
- Updates the auto-scroll state when the chat session changes or when the user scrolls.
- Scrolls the container to the bottom when new messages arrive and auto-scroll is enabled.

## Dependencies
| Dependency | Purpose |
|:-----------|:--------|
| react | Core React library for building the component |
| @mui/material | Material-UI library for styling the component |
| @chainlit/react-client | Custom hooks for accessing chat-related data |

## Performance Considerations
The component uses `useEffect` with appropriate dependencies to optimize re-renders and scroll updates. The `handleScroll` function could potentially be optimized with debouncing if frequent scroll events become a performance issue.