---
title: "Overview"
---

## High-level description
This directory contains SQL migration scripts for dropping the `user_plans` table and its associated index from a database schema. It consists of two files: `up.sql` for applying the changes and `down.sql` for reverting them. These migrations are likely part of a database schema management system, possibly using a tool like Diesel or another ORM for Rust applications.

## What does it do?
The migration scripts in this directory perform the following actions:

1. The `up.sql` script:
   - Removes the `user_plans` table from the database if it exists.
   - Drops the index named `idx_user_plans_stripe_customer_id` if it exists.

2. The `down.sql` script:
   - Recreates the `user_plans` table with specific columns for storing user subscription plan information.
   - Adds an index on the `stripe_customer_id` column of the newly created `user_plans` table.

These scripts allow developers to manage changes to the database schema, specifically related to user plans and Stripe integration. The `up.sql` script is used to apply the changes (dropping the table and index), while the `down.sql` script provides a way to revert these changes if needed (recreating the table and index).

## Key Files

1. `up.sql`:
   This file contains the SQL commands to drop the `user_plans` table and its associated index. It uses `DROP TABLE IF EXISTS` and `DROP INDEX IF EXISTS` commands to ensure idempotency, meaning the script can be run multiple times without causing errors if the table or index no longer exists.

   ```sql
   DROP TABLE IF EXISTS user_plans;
   DROP INDEX IF EXISTS idx_user_plans_stripe_customer_id;
   ```

2. `down.sql`:
   This file contains the SQL commands to recreate the `user_plans` table and its index. It defines the table structure with columns for id, Stripe customer and subscription IDs, plan type, status, and timestamps. It also creates an index on the `stripe_customer_id` column for improved query performance.

   ```sql
   CREATE TABLE user_plans (
     id UUID PRIMARY KEY,
     stripe_customer_id TEXT NOT NULL UNIQUE,
     stripe_subscription_id TEXT NOT NULL UNIQUE,
     plan TEXT NOT NULL,
     status TEXT NOT NULL,
     created_at TIMESTAMP NOT NULL,
     updated_at TIMESTAMP NOT NULL
   );

   CREATE INDEX idx_user_plans_stripe_customer_id ON user_plans (stripe_customer_id);
   ```

## Dependencies
These migration scripts rely on a database migration tool, likely Diesel for Rust applications, to manage and apply the changes to the database schema. The scripts are written in SQL and are designed to work with a PostgreSQL database, as evidenced by the use of the UUID data type and the TIMESTAMP type without time zone.

## Configuration
While there are no explicit configuration files in this directory, the migration scripts themselves serve as a form of configuration for the database schema. The naming convention of the directory (2023-12-06-034507_drop-user-plans-table) suggests that these migrations are part of a versioned migration system, where the timestamp in the directory name indicates when the migration was created and helps maintain the order of migrations.

The `user_plans` table structure defined in the `down.sql` file provides insight into the configuration of user plan data:

- `id`: UUID used as the primary key
- `stripe_customer_id`: Text field for Stripe customer identification (unique)
- `stripe_subscription_id`: Text field for Stripe subscription identification (unique)
- `plan`: Text field to store the plan type
- `status`: Text field to store the subscription status
- `created_at` and `updated_at`: Timestamp fields for record creation and last update times

The presence of Stripe-related fields indicates that this application integrates with Stripe for handling user subscriptions and payments.

When applying these migrations, developers should be aware of the potential impact on existing data and application functionality. The `up.sql` script will permanently remove the `user_plans` table and its data, so it should be used with caution in production environments. Proper backups and testing should be performed before applying such migrations to ensure data integrity and application stability.