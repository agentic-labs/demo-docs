---
title: "metrics-svc.yaml"
---

## High-level description
This code defines a Kubernetes Service named `[RELEASE_NAME]-redis-metrics` that exposes metrics for a Redis deployment. It is conditionally created based on the `metrics.enabled` value in the Helm chart's values file.

## References
* `common.names.fullname`: A Helm template function that constructs the full name of the release.
* `common.names.namespace`: A Helm template function that retrieves the namespace for the release.
* `common.labels.standard`: A Helm template function that generates standard labels for the service.
* `common.tplvalues.merge`: A Helm template function that merges multiple values.
* `common.tplvalues.render`: A Helm template function that renders a template with given values.
* `common.labels.matchLabels`: A Helm template function that generates label selectors.

## Symbols
### `metrics-svc.yaml`
#### Description
This code defines a Kubernetes Service resource in YAML format. It exposes metrics for a Redis deployment on a configurable port.

#### Inputs
This code snippet takes its input from the values passed to the Helm chart during deployment. The relevant values are:
* `.Values.metrics.enabled`: A boolean value indicating whether the metrics service should be created.
* `.Values.metrics.service`: An object containing configuration options for the service, such as the service type, port, and annotations.
* `.Values.commonLabels`: An object containing common labels to be applied to the service.
* `.Values.commonAnnotations`: An object containing common annotations to be applied to the service.

#### Outputs
This code generates a Kubernetes YAML manifest for a Service object.

#### Internal Logic
1. **Conditional Creation:** The service is created only if `.Values.metrics.enabled` is set to `true`.
2. **Name and Namespace:** The service name is constructed using the release name and `-metrics` suffix. The namespace is determined from the `common.names.namespace` template function.
3. **Labels:** Standard labels are applied to the service using the `common.labels.standard` template function. Additionally, the label `app.kubernetes.io/component: metrics` is added.
4. **Annotations:** If defined, annotations from `.Values.metrics.service.annotations` and `.Values.commonAnnotations` are merged and applied to the service.
5. **Service Specification:**
    * **Type:** The service type is determined by `.Values.metrics.service.type`.
    * **ClusterIP:** If the service type is `ClusterIP`, the `clusterIP` field can be set using `.Values.metrics.service.clusterIP`.
    * **External Traffic Policy:** For `LoadBalancer` type services, the `externalTrafficPolicy` can be configured.
    * **Load Balancer IP:** For `LoadBalancer` type services, a specific `loadBalancerIP` can be assigned.
    * **Load Balancer Class:** For `LoadBalancer` type services, a specific `loadBalancerClass` can be assigned.
    * **Load Balancer Source Ranges:** For `LoadBalancer` type services, the allowed `loadBalancerSourceRanges` can be specified.
6. **Ports:**
    * A default port named `http-metrics` is defined with the port number specified by `.Values.metrics.service.port` and targeting the `metrics` port on the Redis pods.
    * Additional ports can be defined using `.Values.metrics.service.extraPorts`.
7. **Selector:** The service targets pods with labels matching those generated by the `common.labels.matchLabels` template function.

## Side Effects
This code, when deployed, will create a Kubernetes Service resource. This service will expose the metrics endpoint of the Redis deployment.

## Dependencies
This code depends on the following Helm template functions:
* `common.names.fullname`
* `common.names.namespace`
* `common.labels.standard`
* `common.tplvalues.merge`
* `common.tplvalues.render`
* `common.labels.matchLabels`

These functions are likely defined in the `common` library chart referenced in the related code snippets.
