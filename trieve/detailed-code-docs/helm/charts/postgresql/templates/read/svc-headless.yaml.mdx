---
title: "svc-headless.yaml"
---

## High-level description
This code defines a Kubernetes Service of type `ClusterIP` for read replicas of a PostgreSQL database in a replication setup. It exposes the PostgreSQL port and configures the service to publish addresses of all pods, even if they are not ready yet.

## Code Structure
The code uses a conditional block to only define the service if the `architecture` value is set to `replication`. It leverages several template functions and includes to generate names, labels, annotations, and port numbers.

## References
* `postgresql.v1.readReplica.svc.headless`: Template function to generate the service name.
* `common.labels.standard`: Template function to generate standard labels.
* `common.tplvalues.merge`: Template function to merge annotations.
* `common.tplvalues.render`: Template function to render annotations.
* `postgresql.v1.readReplica.service.port`: Template function to get the PostgreSQL port number.
* `common.labels.matchLabels`: Template function to generate label selectors.

## Symbols
### `helm/charts/postgresql/templates/read/svc-headless.yaml`
#### Description
This code defines a Kubernetes Service resource for read replicas in a PostgreSQL replication setup. It sets up a headless service, meaning it does not assign a cluster IP and instead directly exposes the pods backing the service.

#### Inputs
This code uses values from the Helm chart's `Values` object. Relevant values include:
| Name | Type | Description |
|:-----|:-----|:------------|
| `Values.architecture` | string | The architecture of the PostgreSQL deployment (e.g., "replication"). |
| `Values.commonLabels` | map | Common labels to apply to the service. |
| `Values.readReplicas.service.headless.annotations` | map | Annotations specific to the read replica headless service. |
| `Values.commonAnnotations` | map | Common annotations to apply to the service. |
| `Values.readReplicas.podLabels` | map | Labels specific to the read replica pods. |

#### Outputs
This code generates a Kubernetes YAML manifest for a Service object.

#### Internal Logic
1. **Conditional Definition:** The service is defined only if `Values.architecture` is set to `replication`.
2. **Metadata:**
    * The service name is generated using the `postgresql.v1.readReplica.svc.headless` template function.
    * Standard labels are applied using `common.labels.standard`, including custom labels from `Values.commonLabels`.
    * Annotations are merged from `Values.readReplicas.service.headless.annotations` and `Values.commonAnnotations` and rendered using `common.tplvalues.merge` and `common.tplvalues.render`.
    * The `service.alpha.kubernetes.io/tolerate-unready-endpoints` annotation is set to `true` for compatibility.
3. **Spec:**
    * The service type is set to `ClusterIP`.
    * `clusterIP` is set to `None` to create a headless service.
    * `publishNotReadyAddresses` is set to `true` to expose pod addresses even before they are ready.
4. **Ports:**
    * A port named `tcp-postgresql` is defined with the port number obtained from `postgresql.v1.readReplica.service.port` and targeting the `tcp-postgresql` port on the pods.
5. **Selector:**
    * The service selector is generated using `common.labels.matchLabels`, matching pods with the `app.kubernetes.io/component: read` label and any custom labels defined in `Values.readReplicas.podLabels` and `Values.commonLabels`.

## Side Effects
This code, when applied to a Kubernetes cluster, will create a new Service object.

## Dependencies
This code depends on the following Helm template functions:
* `postgresql.v1.readReplica.svc.headless`
* `common.labels.standard`
* `common.tplvalues.merge`
* `common.tplvalues.render`
* `postgresql.v1.readReplica.service.port`
* `common.labels.matchLabels`

It also relies on Kubernetes APIs for creating and managing Service objects.
