---
title: "client.go"
---

## High-level description
This code implements the client-side functionality of the Secure Remote Password (SRP) protocol. It provides methods for generating and verifying cryptographic values used in the SRP authentication process, allowing secure password-based authentication without transmitting the password itself.

## Code Structure
The main structure is `SRPClient`, which holds the necessary parameters and computed values for the SRP protocol. Various functions are provided to perform different steps of the protocol, such as computing the public value A, setting the server's public value B, and verifying the server's proof M2.

## Symbols

### `SRPClient`
#### Description
A struct that represents the client-side of the SRP protocol, containing all necessary parameters and computed values.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| Params | *SRPParams | SRP protocol parameters |
| Secret1 | *big.Int | Client's secret value |
| Multiplier | *big.Int | Protocol multiplier |
| A | *big.Int | Client's public value |
| X | *big.Int | Client's private key |
| M1 | []byte | Client's proof of key |
| M2 | []byte | Server's expected proof of key |
| K | []byte | Shared session key |
| u | *big.Int | Random scrambling parameter |
| s | *big.Int | Shared secret |

### `NewClient`
#### Description
Creates a new SRPClient instance with the given parameters, identity, password, and secret value.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| params | *SRPParams | SRP protocol parameters |
| identity | []byte | User's identity |
| password | []byte | User's password |
| secret1 | []byte | Client's secret value |

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| client | *SRPClient | New SRPClient instance |

### `ComputeA`
#### Description
Computes and returns the client's public value A.

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| A | []byte | Client's public value |

### `ComputeVerifier`
#### Description
Computes the verifier using the given parameters, salt, identity, and password.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| params | *SRPParams | SRP protocol parameters |
| salt | []byte | Salt value |
| identity | []byte | User's identity |
| password | []byte | User's password |

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| verifier | []byte | Computed verifier |

### `SetB`
#### Description
Sets the server's public value B and computes the shared key and proofs.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| Bb | []byte | Server's public value B |

### `SetSalt`
#### Description
Sets the salt and recomputes the client's private key X.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| salt | []byte | Salt value |
| identity | []byte | User's identity |
| password | []byte | User's password |

### `ComputeM1`
#### Description
Returns the client's proof of key M1.

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| M1 | []byte | Client's proof of key |

### `ComputeK`
#### Description
Returns the computed shared session key K.

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| K | []byte | Shared session key |

### `CheckM2`
#### Description
Verifies the server's proof of key M2.

#### Inputs
| Name | Type | Description |
|:-----|:-----|:------------|
| M2 | []byte | Server's proof of key |

#### Outputs
| Name | Type | Description |
|:-----|:-----|:------------|
| error | error | Error if M2 doesn't match, nil otherwise |

## Dependencies
| Dependency | Purpose |
|:-----------|:--------|
| bytes | For comparing byte slices |
| errors | For creating error instances |
| math/big | For big integer arithmetic operations |

## Error Handling
The code uses panic for critical errors (e.g., incomplete protocol, invalid server-supplied 'B'). For non-critical errors, it returns an error value (e.g., in `CheckM2`).

## Performance Considerations
The code uses big integer arithmetic, which can be computationally expensive. Care should be taken when using this in performance-critical applications, especially with large parameter values.