---
title: "Overview"
---

## High-level description
This directory contains models representing customers for different payment providers within a larger application. It includes a base class (`BaseCustomer`) and specific implementations for Adyen, GoCardless, and Stripe payment providers. These models handle the storage and management of customer-specific data for each payment provider.

## What does it do?
The code in this directory manages customer information for various payment providers. It allows the application to:

1. Store and retrieve customer-specific data for each payment provider.
2. Associate customers with their respective payment providers and the main customer record in the system.
3. Track payments and refunds associated with each payment provider customer.
4. Manage provider-specific settings and payment methods.
5. Ensure data integrity through validations and constraints.

For example, when a customer decides to use Stripe for payments, a `StripeCustomer` record is created, storing Stripe-specific information like the customer's Stripe ID and preferred payment methods. This record is then associated with the main customer record in the system, allowing for easy management of payment-related data across different providers.

## Key Files

1. `base_customer.rb`: This is the foundation for all payment provider customer models. It defines common attributes, relationships, and behaviors shared across different payment providers.

2. `adyen_customer.rb`: Represents customers using the Adyen payment platform. It adds an accessor for the `payment_method_id` setting specific to Adyen.

3. `gocardless_customer.rb`: Represents customers using the GoCardless payment system. It inherits all functionality from `BaseCustomer` without adding any specific behavior.

4. `stripe_customer.rb`: Represents customers using the Stripe payment platform. It adds Stripe-specific validations and settings, including management of allowed payment methods.

## Dependencies
The models in this directory rely on the following dependencies:

1. ActiveRecord: Used for database interactions and model structure.
2. PaperTrail: Utilized for tracking changes to the models (version control).
3. SettingsStorable: A custom module for managing settings storage within the models.

## Configuration
The `BaseCustomer` class defines several settings accessors that are used across all payment provider customer models:

```ruby
settings_accessors :provider_mandate_id, :sync_with_provider
```

These settings allow for storing provider-specific mandate IDs and controlling synchronization with the provider.

The `StripeCustomer` class defines additional settings:

```ruby
settings_accessors :payment_method_id
```

This allows for storing Stripe-specific payment method IDs.

Additionally, the `StripeCustomer` class defines a constant `PAYMENT_METHODS` that lists allowed payment methods:

```ruby
PAYMENT_METHODS = %w[card sepa_debit link].freeze
```

This constant is used in validations to ensure only allowed payment methods are used for Stripe customers.

## Key Concepts and Functionality

1. Inheritance and Specialization:
   The `BaseCustomer` class serves as a foundation, with provider-specific classes (`AdyenCustomer`, `GocardlessCustomer`, and `StripeCustomer`) inheriting from it. This allows for shared functionality while enabling provider-specific customizations.

   Example:
   ```ruby
   class AdyenCustomer &lt; PaymentProviderCustomers::BaseCustomer
     settings_accessors :payment_method_id
   end
   ```

2. Associations:
   The `BaseCustomer` class defines associations with other models in the system:

   ```ruby
   belongs_to :customer
   belongs_to :payment_provider
   has_many :payments
   has_many :refunds
   ```

   These associations allow for easy navigation between related records, such as finding all payments for a specific payment provider customer.

3. Validations:
   The models implement various validations to ensure data integrity. For example, the `BaseCustomer` class ensures that a customer is unique for a specific payment provider type:

   ```ruby
   validates :customer_id, uniqueness: { scope: :type }
   ```

   The `StripeCustomer` class adds more specific validations, such as ensuring only allowed payment methods are used:

   ```ruby
   validate :allowed_provider_payment_methods
   ```

4. Settings Management:
   The models use the `SettingsStorable` module to manage provider-specific settings. This allows for flexible storage of attributes that may vary between providers without requiring database schema changes.

   Example usage in `StripeCustomer`:
   ```ruby
   def provider_payment_methods
     super || settings[:provider_payment_methods] || []
   end

   def provider_payment_methods=(value)
     settings[:provider_payment_methods] = value
   end
   ```

5. Extensibility:
   The `BaseCustomer` class includes a `provider_payment_methods` method intended to be overridden by subclasses:

   ```ruby
   def provider_payment_methods
     raise NotImplementedError
   end
   ```

   This allows each provider-specific class to implement its own logic for handling payment methods.

In summary, this directory provides a flexible and extensible system for managing customer data across multiple payment providers. It uses object-oriented principles to share common functionality while allowing for provider-specific customizations, ensuring that the application can easily support multiple payment providers with minimal code duplication.